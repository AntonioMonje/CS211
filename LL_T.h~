//Antonio Monje
//cs211 Assignment 7
//LL Class - header file
//==================================================================================================================
#ifndef LL_H
#define LL_H
#include <iostream>
#include <string>
using namespace std;



//create a struct that will have an operand, a operator, another operand
template <class T>
struct node
{
  T elem;//variable of el_t
  node<T>* next;//makes next a node
};

template <class T>
class LL
{
 private:
  // Data members are:
  int count; //count is the variable that counts how many element we have
  node<T>* front; //where the front element of the queue is.
  node<T>* rear; //where the rear element of the queue is.
  //a private utility function for fatal error cases
  //This displays an error messages passed to it and does exit(1);
  void queueError(string);
 public:
  //Purpose to initialize the data members
  //Parameters: nothing
  //HOW TO CALL: dont have to pass anything to it
  LL();//default constructor
  //Purpose to destroy
  //Parameters: nothing
  //HOW TO CALL: dont have to pass anything to call it gets called at end of function to delete the linked list
  ~LL();//Default destructor
  //Purpose to check if the queue is empty
  //Parameters: nothing
  //HOW TO CALL: dont have to pass anything
  bool isEmpty();// holds the function that tells if the stack has nothing
  //Purpose to add to the queue
  //Parameters: el_t
  //HOW TO CALL: pass an element to add to the rear of the linked list
  void addRear(T);// holds the function for adding an element to the queue
  //Purpose to delete elements from queue
  //Parameters: nothing
  //HOW TO CALL: Dont have to pass anything to this function
  T deleteFront();// holds the function showing the front element
  //Purpose to displays the content of the queue
  //Parameters: nothing
  //HOW TO CALL: Dont have to pass anything to this function
  void displayAll();// holds the function for showing all elements in the stack
  //Purpose to display the queue in reverse order
  //Parameters: nothing
  //HOW TO CALL: Dont have to pass anything to this function
  void PrintAllReverse();
  //Purpose reverses the queue
  //Parameters: pointer node p
  //HOW TO CALL: you pass a pointer to the function to call it
  void PrintAllReverse(node<T>* p);
  //Purpose to add element to the front
  //Parameters: an element of el_t to add to the front
  //HOW TO CALL: you pass an element of el_t to add to the front of the list
  void addFront(T el);
  //Purpose to delete the last element of the linked list
  //Parameters: nothing
  //HOW TO CALL: Dont have to pass anything to this function
  T deleteRear();
  //Purpose to delete a element
  //Parameters: an element of el_t to add 
  //HOW TO CALL: you pass an element of el_t to delete from the list  
  void deleteNode(T el);
  //Purpose to add element to the list
  //Parameters: an element of el_t to add in ascending order
  //HOW TO CALL: you pass an element of el_t to add to the list
  void addInOrderAscend(T el);
  //Purpose to look for a element
  //Parameters: an element of el_t to find
  //HOW TO CALL: you pass an element of el_t to look for
  bool search(T el);
  //Purpose to add element to the list
  //Parameters: an element of el_t to add to the list
  //HOW TO CALL: you pass an element of el_t to add the list in descending order
  void addInOrderDescend(T el);
  //Purpose to delete multiple nodes from the list
  //Parameters: an element of el_t to delete from the list
  //HOW TO CALL: you pass an element of el_t to add to delete from the list
  void deleteNodes(T el);
};

template<class T>
LL<T>::LL()
{
  count = 0;
  front = NULL;
  rear = NULL;
}
template<class T>
LL<T>::~LL()
{
  while(!isEmpty())//checks is empty function
    {
      deleteFront();//deletes front element
    }
}
template<class T>
void LL<T>::addRear(T el)
{
  if(count == 0)//checks if count is zer if yes front and rear make a new node
    front = rear = new node<T>;
  else// else rear points to next and that make a  new node
    {
      rear-> next = new node<T>;
      rear = rear -> next;
    }
  rear-> elem = el;// rear is set to the new element added
  rear-> next = NULL;//then rear points to a null character
  count++;// increment
}

template<class T>
T LL<T>::deleteFront()
{
  T e;
  if(isEmpty())//checks is empty
    queueError("The queue is Empty. Cannot delete!");
  else// make temp that is set to fromt and makes front point to next
    {
      node<T>* temp = front;
      front = front -> next;
      e = temp -> elem;//sets element to temp
      count--;
      delete temp;//deletes temp after front changes
      if(front == NULL)//if front is null the set rear to null
	rear = NULL;

      return e;// return deleted element
    }
}

template<class T>
bool LL<T>::isEmpty()
{
  if(front == NULL && rear == NULL)//if both are null then its empty
    return true;
  else// else it has something inside queue
    return false;
}

template<class T>
void LL<T>::displayAll()
{

  node<T>* p = front;
  while(p != NULL)// if p is not null then cout element
    {
      cout << p -> elem;
      p = p -> next;// then point to next element
    }
}

template<class T>
void LL<T>::queueError(string msg)
{
  cout << msg << endl;// display a error message
  exit(1);
}

template<class T>
void LL<T>::PrintAllReverse()
{
  PrintAllReverse(front);// dislplays the answer in reverse
}

template<class T>
void LL<T>::PrintAllReverse(node<T>* p)
{
  if(p == NULL)// if node is null do nothing
    return;
  else// point to element and display it
    {
      PrintAllReverse(p -> next);
      cout << p -> elem;
    }
}

template<class T>
void LL<T>::addFront(T el)
{
  if(count == 0)//checks if count is zer0 if yes front and rear make a new node
    addRear(el);
  else// else front points to next and that make a  new node
    {
      node<T>* x = front;
      front = new node<T>;
      front-> elem = el;
      front-> next = x;
      count++;
    }
}

template<class T>
T LL<T>::deleteRear()
{
  T e;
  if(isEmpty())//checks is empty
    queueError("The queue is Empty. Cannot delete!");
  else if(count == 1)
    {
      e = deleteFront();
    }
  else// make temp that is set to fromt and makes front point to next
    {
      e = rear -> elem;
      node<T>* p = front;
      while(p->next!=rear)//while loop to set temp to element before rear
        {
          p = p->next;
        }
      delete rear;// delete rear
      rear = p;// make rear point to the temp which was one before the rear
      rear->next = NULL;
      count--;// increment the count
    }
  return e;// return e
}

template<class T>
void LL<T>::deleteNode(T el)
{
  if(!isEmpty())
    {
      if(front->elem == el)//if the first element is the key then delete it
	deleteFront();

      else// else go through the for loop
        {
          node<T>* pre;
          node<T>* del;
	  for(pre = front, del = front -> next; del!=NULL && del-> elem != el; pre = del, del = del -> next)
            ;
	  if(del != NULL)// if not null the set pre next equal to del next
            {
              pre->next=del->next;
              if(del==rear)// if del(current) node is equal to rear set rear equal to pre then delete
                rear=pre;
              delete del;// delete the node
              count--;//increment
            }
        }
    }
}

template<class T>
void LL<T>::addInOrderAscend(T el)
{

  if(isEmpty())//checks if empty if yes then add to the front
    addFront(el);
  else if(el < front -> elem)// checks for first element if smaller than first element add to the front
    addFront(el);
  else
    {
      node<T>* p = front;
      while(p->next != NULL && p -> next -> elem < el)//while not null and element is less than element in front
        p = p -> next;

      node<T>* x = new node<T>;// make a temp node
      x-> elem = el; // set temp equal to the lement
      x-> next = p->next;// set the nodes equal to each other
      p->next = x;// set the node equal to the temp
      count++;  // increment
    }
}

template<class T>
bool LL<T>::search(T el)
{
  T comparison;
  node<T>* p = front;//make temp node equal to front
  while(p != NULL)//while node is not null
    {
      //      comparison++;
      if(p->elem == el)//if temp node is equal to element your looking for return true
        {
	  //  cout << comparison << " Times Compared " << endl;
          return true;
        }
      else// if not the element move to next element
        {
          p = p -> next;
        }
    }
  //  cout << comparison << " Times Compared " << endl;
  return false;// if element is not found return false
}

template<class T>
void LL<T>::addInOrderDescend(T el)
{
  if(isEmpty())//if list is empty add element to the front
    addFront(el);
  else if(el > front -> elem)// if its the first element is bigger then the element add it to the front
    addFront(el);
  else// if not empty and not the first element
    {
      node<T>* p = front;// make temp node equal to front
      while(p->next != NULL && p -> next -> elem >= el)//if not null and element is greater than el point to next el\ement
  p = p -> next;

      node<T>* x = new node<T>;// make a second temp node
      x-> elem = el;// the temp points to the element passed to the function
      x-> next = p->next;//set secont temp equal to the next temp
      p->next = x;// set the first temp node equal to the second
      count++;// increment
    }
}

template<class T>
void LL<T>::deleteNodes(T el)
{
  node<T>* pre;
  node<T>* del;
  if(isEmpty())//if list is empty return nothing
    {
      return;
    }
  else// if not empty empty
    {
      if(front -> elem == el)// if front element is equal to what your looking for delete that node
        {
          deleteFront();
        }
      if(count > 1)// if not the front element and count is greater than 1
        {

          pre = front;//set to fron
          del = front -> next;// set to front next next

          for(pre, del; del != NULL; pre = del, del = del -> next)//for loop while del is not null
            {

              if(del == rear && del -> elem == el)// if its rear and del node equals that el deletet the rear
                deleteRear();
              else if(del -> elem == el)//if it just equal to element set pre next equal to del next and delete
                {
                  pre -> next = del -> next;
                  delete del;
                  count--;// increment
                }
            }
        }
    }
}

#endif



